# Rust-JNI complete example

This project is supposed to serve both as a simple yet complete example of what `rust-jni` can do and as an set of integration tests to ensure that the library works correctly with real-world JVMs.

## Project structure

This project consists of four components: a Java library (in `/java/rustjni/test`), a Rust library (in `/`), a shared library wrapping the Rust library (in `/dylib`) and Rust binaries with tests (in `/tests`). The test binaries are Rust programs that want to use the Java library. The Rust library is a usual Rust library crate that contains code generated by `rust-jni` from manual configration that allows the user (in this case it's the person who writes the test binary) to seamlessly call these Java classes in a natural Rust-native API. The shared library is a `dylib` Rust crate that doesn't contain any code and only imports the Rust library. It's purpose is to compile the same Rust library the tests use to call Java code into a shared library that can be loaded by Java to link the native methods.

## Test workflow

Each test first uses `rust-jni` to start a JVM and load classes from the Java library for them to become available and then proceeds with calling the Java code. Each test imports the Rust library to call Java methods.

### The method calls test

The first test (`/tests/call_methods.rs`) is a program that calls methods on a Java class. To make it even more interesting, Java methods then call corresponsing native methods linked from the shared library, which, in turn, also call back the Java code which again calls the native code, which this time just returns an argument. This is meant to be a stress test that tests that a complex call stack is possible and is working correctly. This then done for methods recieving and returning all kind of Java primitive and object types. Note how the Java class loads the shared library in a static initialiser.

### The inheritance test

The second test (`/tests/test_inheritance.rs`) is a test of the `rust-jni`-s ability to represent the Java object model. This test loads a few Java classes and interfaces and defines Rust functions that accept `rust-jni` wrappers for these classes and interfaces and call a corresponding method on each of them. The purpose of the test is to verify that an object of each class can be used in place of any of it's superclasses, including `java.lanf.Object`, and any interface it's class or any of it'superclasses implement, just like it can in Java. Thus, this test creates objects of three Java classes and then passes them to methods that recieve a superclass object or an interface implementation.
